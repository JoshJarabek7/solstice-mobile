rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isUserInChat(chatData) {
      return isSignedIn() &&
        (chatData.participants.hasAny([request.auth.uid]) ||
         request.auth.uid in chatData.participantIds);
    }
    
    function isNotDeleted(chatData) {
      return !(request.auth.uid in chatData.deletedForUsers);
    }
    
    function canAccessChat(chatData) {
      return isUserInChat(chatData) && isNotDeleted(chatData);
    }
    
    // For validating chat creation, require that the document has a field 'participantIds' that is a list of strings
    // and that the authenticated user's uid is one of those IDs.
    function hasValidParticipants(chatData) {
      return chatData.participantIds is list && request.auth.uid in chatData.participantIds;
    }
    
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if isSignedIn() && request.auth.uid == userId;
      
      // Add rules for likedVideos subcollection
      match /likedVideos/{videoId} {
        allow read, write: if isSignedIn();
      }
      
      // Add rules for other user-related subcollections
      match /{subcollection}/{docId} {
        allow read: if isSignedIn();
        allow write: if isSignedIn() && request.auth.uid == userId;
      }
    }
    
    match /chats/{chatId} {
      // Allow listing chats with queries
      allow list: if isSignedIn();
      
      // Allow reading a specific chat document
      allow get: if isSignedIn();
      
      // Allow creating new chats - more permissive during development
      allow create: if isSignedIn();
      
      // Allow updating existing chats
      allow update: if isSignedIn();
      
      // Allow deleting chats (only by creator/owner)
      allow delete: if isSignedIn() && 
        (resource.data.createdBy == request.auth.uid ||
         resource.data.ownerId == request.auth.uid);
      
      match /messages/{messageId} {
        // During development, allow all authenticated users to read/write messages
        allow read, write: if isSignedIn();
      }
      
      match /events/{eventId} {
        allow read, write: if isSignedIn();
      }
    }
    
    match /videos/{videoId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn();
      
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update: if isSignedIn() && 
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes']);
        
        match /likes/{userId} {
          allow read: if isSignedIn();
          allow create: if isSignedIn() && request.auth.uid == userId;
          allow delete: if isSignedIn() && request.auth.uid == userId;
        }
      }
      
      // Add rules for likes subcollection
      match /likes/{userId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow delete: if isSignedIn() && request.auth.uid == userId;
      }
      
      // Allow updating the likes count on the video document
      allow update: if isSignedIn() && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'comments']);
    }
    
    // Deny access to all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

service firebase.storage {
  match /b/{bucket}/o {
    match /users/{userId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    match /videos/{videoId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}