rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isUserInChat(chatData) {
      return isSignedIn() &&
        (chatData.participantIds.hasAny([request.auth.uid]) ||
         request.auth.uid in chatData.participantIds);
    }
    
    function isNotDeleted(chatData) {
      return !(request.auth.uid in chatData.deletedForUsers);
    }
    
    function canAccessChat(chatData) {
      return isUserInChat(chatData) && isNotDeleted(chatData);
    }
    
    // For validating chat creation, require that the document has a field 'participantIds' that is a list of strings
    // and that the authenticated user's uid is one of those IDs.
    function hasValidParticipants(chatData) {
      return chatData.participantIds is list && request.auth.uid in chatData.participantIds;
    }
    
    match /users/{userId} {
      // During development, allow creation without auth check
      allow create: if true;  // More permissive during development
      allow read: if true;    // More permissive during development
      allow update: if isSignedIn() && 
        (request.auth.uid == userId || 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['chats']));
      allow delete: if request.auth != null && request.auth.uid == userId;
      
      // Add rules for likedVideos subcollection
      match /likedVideos/{videoId} {
        allow read, write: if isSignedIn();
      }
      
      // Add rules for other user-related subcollections
      match /{subcollection}/{docId} {
        allow read: if isSignedIn();
        allow write: if isSignedIn() && request.auth.uid == userId;
      }
    }
    
    match /chats/{chatId} {
      // Allow listing chats with queries
      allow list: if isSignedIn();
      
      // Allow reading a specific chat document
      allow get: if isSignedIn();
      
      // Allow creating new chats - more permissive during development
      allow create: if isSignedIn();
      
      // Allow updating existing chats
      allow update: if isSignedIn();
      
      // Allow deleting chats (only by creator/owner)
      allow delete: if isSignedIn() && 
        (resource.data.createdBy == request.auth.uid ||
         resource.data.ownerId == request.auth.uid);
      
      match /messages/{messageId} {
        // During development, allow all authenticated users to read messages
        allow read: if isSignedIn() && 
          get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
        
        // Allow creating messages if user is a chat participant
        allow create: if isSignedIn() && 
          get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]) &&
          request.resource.data.senderId == request.auth.uid;
        
        // Allow updating messages (for reactions, etc.)
        allow update: if isSignedIn() && 
          get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      }
      
      match /events/{eventId} {
        allow read, write: if isSignedIn();
      }
    }
    
    // Add collection group rules for likes
    match /{path=**}/likes/{likeId} {
      allow read: if isSignedIn();
    }
    
    match /videos/{videoId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn();
      
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update: if isSignedIn() && 
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes']);
        
        match /likes/{userId} {
          allow read: if isSignedIn();
          allow create: if isSignedIn() && request.auth.uid == userId;
          allow delete: if isSignedIn() && request.auth.uid == userId;
        }
      }
      
      // Add rules for likes subcollection
      match /likes/{userId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow delete: if isSignedIn() && request.auth.uid == userId;
      }
      
      // Allow updating the likes count on the video document
      allow update: if isSignedIn() && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'comments']);
    }
    
    // Add rules for likes collection
    match /likes/{likeId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow delete: if isSignedIn();
    }
    
    // Add rules for passes collection
    match /passes/{passId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && 
        request.resource.data.passerId == request.auth.uid;
      allow delete: if isSignedIn() && 
        resource.data.passerId == request.auth.uid;
    }
    
    // Add rules for matches collection
    match /matches/{matchId} {
      allow read: if isSignedIn() && 
        request.auth.uid in resource.data.users;
      allow create: if isSignedIn() && 
        request.auth.uid in request.resource.data.users;
      allow update: if isSignedIn() && 
        request.auth.uid in resource.data.users;
      allow delete: if isSignedIn() && 
        request.auth.uid in resource.data.users;
    }
    
    // Deny access to all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

service firebase.storage {
  match /b/{bucket}/o {
    match /users/{userId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    match /videos/{videoId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}